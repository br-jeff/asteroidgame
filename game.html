<!DOCTYPE html>
<html>
    <meta charset="UTF-8">
    <head>
        <title>Asteroid Game</title>
    </head>
<body>
    <canvas id="gameCanv" width="700" height="500"></canvas>

    <script>
        const FPS = 30; //frames por segundo
        const friction = 0.7; //frixção para poder mover sem travar
        const SHIP_SIZE = 30; // altura em pixels
        const TURN_SPEED = 360; // 1 RMP = rotação por segundo 
        const SHIP_BOOST = 5; //aceleração em pixels por segundo

        var canv = document.getElementById('gameCanv');
        var ctx = canv.getContext("2d");

        var ship = {
            x: canv.width/2,
            y: canv.height/2,
            r: SHIP_SIZE/2,
            a: 90/180 * Math.PI ,//convertendo para radianos
            rot: 0,
            boosting: false,
            boost: { 
                //faz com que a nave continue a andar depois de soltar seta pr acima
                x: 0,
                y: 0

            }

        }

        //set up event handlers
        document.addEventListener("keydown", keyDown);
        document.addEventListener("keyup", keyUp);
        //fazendo loop do jogo

        function keyDown(event) {

            switch(event.keyCode) {

                case 37: //seta esquerda (rodar para esquerda)
                        ship.rot = TURN_SPEED /180 * Math.PI/FPS;
                    break;
                case 38: // seta para cima ativar boost
                    ship.boosting = true;
                    break;
                case 39: // seta direita (rodar para direita)
                        ship.rot = -TURN_SPEED / 180 * Math.PI/FPS;
                    break;    

            }

        }

        function keyUp(event){
            switch(event.keyCode) {
                case 37: //seta esquerda (para rodar para esquerda)
                        ship.rot = 0;
                    break;
                case 38: // seta para cima (para or boost)
                        ship.boosting = false;
                    break;
                case 39: // seta direita (para rodar para direita)
                        ship.rot = 0;
                    break;     }


        }

        setInterval(update , 1000/FPS)

        function update () {
                // desenhando espaço
            ctx.fillStyle = "black";
            ctx.fillRect(0,0,canv.width,canv.height);

            //desenhando boost
            
            if(ship.boosting) {
                ship.boost.x += SHIP_BOOST * Math.cos(ship.a) /FPS;
                ship.boost.y -= SHIP_BOOST * Math.sin(ship.a) /FPS;

                ctx.fillStyle = "red";
                ctx.strokeStyle = "yellow",
                ctx.lineWidth = SHIP_SIZE /10;
                ctx.beginPath();

                ctx.moveTo(
                    ship.x - ship.r * ( 2/3 * Math.cos(ship.a) + 0.5 * Math.sin(ship.a)),
                    ship.y + ship.r * ( 2/3 * Math.sin(ship.a) - 0.5 * Math.cos(ship.a))
                );

                ctx.lineTo(
                    ship.x - ship.r * 4/3 * Math.cos(ship.a) ,
                    ship.y + ship.r *  4/3 * Math.sin(ship.a) 
                );

                ctx.lineTo(
                    ship.x - ship.r * ( 2/3 * Math.cos(ship.a) - 0.5 * Math.sin(ship.a) ),
                    ship.y + ship.r * ( 2/3 * Math.sin(ship.a) + 0.5 * Math.cos(ship.a) ) 
                )
                
                ctx.closePath();
                ctx.stroke();
                ctx.fill();
            } else {
                ship.boost.x -=  ship.boost.x * friction /FPS;
                ship.boost.y -=  ship.boost.y * friction /FPS;
            }
            // desenhando propoursor 
               


            //desenhando nave triangular
            ctx.strokeStyle = "white",
            ctx.lineWidth = SHIP_SIZE /20;
            ctx.beginPath();

            ctx.moveTo(
                ship.x + 4/3 * ship.r * Math.cos(ship.a),
                ship.y - 4/3 * ship.r * Math.sin(ship.a)
            );

            ctx.lineTo(
                ship.x - ship.r * ( 2/3 * Math.cos(ship.a) + Math.sin(ship.a)),
                ship.y + ship.r * ( 2/3 * Math.sin(ship.a) - Math.cos(ship.a))
            );

            ctx.lineTo(
                ship.x - ship.r * ( 2/3 * Math.cos(ship.a)  - Math.sin(ship.a) ),
                ship.y + ship.r * ( 2/3 *Math.sin(ship.a) + Math.cos(ship.a) ) 
            )
            
            ctx.closePath();
            ctx.stroke();

            //fim desnho nave triangular


            //movimentar a nave
            
            //faz com que continue a se movimentar por um tempo
            ship.x += ship.boost.x;
            ship.y += ship.boost.y;
           //faz com que continue a se movimentar por um tempo

            //rodar a nave
            ship.a += ship.rot;

            //final da tela é inicio do canto oposto
            if (ship.x < 0 - ship.r){
                ship.x = canv.width + ship.r;
            }
            else if (ship.x > canv.width + ship.r ){
                ship.x = 0 - ship.r;
            }
            if (ship.y < 0 - ship.r){
                ship.y = canv.height + ship.r;
            }
            else if (ship.y > canv.height + ship.r ){
                ship.y = 0 - ship.r;
            }
            
            
           
 
              //ponto no centro do triangulo
              ctx.fillStyle= "red";
              ctx.fillRect(ship.x - 1, ship.y - 1, 2,2);
            
        }
        
    </script>
</body>
</html>